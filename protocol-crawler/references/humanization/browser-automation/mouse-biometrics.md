# 鼠标交互拟人 (Advanced Mouse Biometrics)

简单的"点对点"直线移动早已失效，甚至标准的贝塞尔曲线如果参数过于完美也会被识别为"机器生成的平滑"。

## 1. 轨迹算法进阶：从几何到物理

传统的贝塞尔曲线是"几何完美"的，而人的手受限于肌肉张力、骨骼结构和神经信号的噪声，轨迹是"物理不完美"的。

### A. 基础路径：多阶贝塞尔 (Multi-Order Bézier)

不要只用二阶（起点、终点、1个控制点）。

**业内做法：动态选择阶数**

- 短距离 (<100px)：二阶贝塞尔
- 中长距离 (>100px)：三阶或四阶贝塞尔（2-3个控制点）

**控制点生成算法（关键）**：

1. **连线**：连接起点 P₀ 和终点 Pₙ
2. **法向偏移**：在连线上取分点，然后沿垂直方向（法线）进行随机偏移
3. **非对称性**：控制点的分布不应是对称的。人手在启动时更稳定，中段更飘忽。靠近起点的控制点偏移量应较小，中间的控制点偏移量较大

### B. 噪声叠加：柏林噪声 (Perlin Noise)

这是区分脚本与真人的"神之一手"。

**为什么不是 Random?**

- `Math.random()` 是白噪声，跳跃极大，不连续
- 叠加在轨迹上会像帕金森震颤，很不自然

**为什么要用柏林噪声?**

- 柏林噪声是梯度噪声，变化是平滑、连续的波形
- 完美模拟了手臂肌肉在移动时的惯性漂移

**实现逻辑**：

```
P_final(t) = P_bezier(t) + Noise_perlin(t) × Scale
```

- `t`: 时间进度 (0.0 -> 1.0)
- `Scale`: 随着接近终点，Scale 必须衰减至 0（因为人越接近目标，手抓得越稳，为了对准）

## 2. 过冲与修正 (Overshoot & Correction)

模拟"人类视觉反馈延迟"的关键机制。

**现象**：当你快速移动鼠标去点一个大按钮，你的手通常会甩过头，眼睛看到"过头了"，大脑下达指令，手再拉回来。

**核心算法流程**：

1. **判断条件**：只有当移动距离 D > 200px 且目标尺寸较大时，才触发过冲逻辑
2. **虚假目标 (Phantom Target)**：
   - 计算起点到终点的向量 V
   - 设定虚假目标点 P_phantom = P_end + V × α
   - α 是过冲系数，通常在 0.05 ~ 0.15 之间随机（即超出 5%-15%）
3. **两段式移动**：
   - 阶段一（冲刺）：快速移动到 P_phantom
   - 阶段二（回正）：到达虚假目标后，必须停顿（50ms - 150ms）
   - 阶段三（修正）：以较低的速度、较高的精度从 P_phantom 移动回真实的 P_end

## 3. 速度与加速度：菲茨定律 (Fitts's Law)

不要简单的 ease-in-out。真实的鼠标速度是受菲茨定律支配的。

### A. 时间预测模型

不要硬编码"移动需要 1 秒"。移动时间 MT 必须动态计算：

```
MT = a + b × log₂(1 + D/W)
```

- D: 距离 (Distance)
- W: 目标宽度 (Width)
- a, b: 经验常数（通常取 a ≈ 100ms, b ≈ 100ms 左右的随机浮动值）

**含义**：目标越远、目标越小，你需要的时间就越长。

### B. 速度曲线构建 (Velocity Profile)

1. **启动 (Ease-In)**：极快。人点击意图产生后，爆发力最强
2. **巡航 (Coast)**：速度达到峰值
3. **制动 (Braking)**：重点！接近目标时，速度下降的曲线不是线性的，而是指数级的

### C. 数据采样率陷阱

- **Bot**: 1秒内发送 1000 个 mousemove 事件
- **Human**: 浏览器的 mousemove 触发频率通常与显示器刷新率同步（60Hz 或 144Hz）
- **修正**：你的轨迹生成算法每秒产出的点数，不应超过 60-120 个

## 4. 悬停与犹豫 (Hover & Hesitation)

### A. 确认性抖动 (Confirmation Jitter)

在点击按钮（Click）之前，不要马上 Click。

**动作序列**：

1. 轨迹到达按钮中心区域
2. Micro-movement: 在按钮范围内，围绕中心点做一个极小半径（< 3px）的随机游走，持续 100ms-300ms
3. 然后才 Click

**含义**：模拟了手指在按下去之前的最后确认

### B. 熵值维持 (Entropy Maintenance)

即使不进行操作，鼠标也不应完全静止不动。

**方案**：

- 如果不操作超过 2 秒，添加一个"呼吸抖动"
- 每隔几百毫秒，坐标 (x, y) 发生 ±1 像素的漂移
- 模拟了光电鼠标传感器的噪点，或者桌面的微小震动

## 技术栈清单

| 组件     | 推荐库                        |
| -------- | ----------------------------- |
| 数学库   | `numpy`, `scipy.interpolate`  |
| 噪声库   | `noise` (Python Perlin Noise) |
| 轨迹封装 | `py-ghost-cursor`             |

**核心逻辑**：

1. 实现 Fitts's Law 计算 total_duration
2. 实现 4阶贝塞尔 + Perlin Noise 生成路径点集 points[]
3. 对 points[] 进行时间重映射 (Time Remapping)，使其符合"急加速-慢减速"的速度曲线
4. 对最终输出的事件流进行 60Hz 降采样
